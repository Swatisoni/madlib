# coding=utf-8
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
import plpy
from utilities.control import MinWarning
from utilities.utilities import _assert
from utilities.utilities import unique_string
from utilities.validate_args import table_exists
from utilities.validate_args import columns_exist_in_table
from utilities.validate_args import table_is_empty
from utilities.validate_args import get_cols
from utilities.utilities import py_list_to_sql_string
from collections import defaultdict 

m4_changequote(`<!', `!>')

def balance_sample(schema_madlib, source_table, output_table, class_col,
    class_sizes, output_table_size, grouping_cols, with_replacement, **kwargs):

    """
    Balance sampling function
    Args:
        @param source_table       Input table name.
        @param output_table       Output table name.
        @param class_col          Name of the column containing the class to be
                                  balanced.
        @param class_size         Parameter to define the size of the different
                                  class values.
        @param output_table_size  Desired size of the output data set.
        @param grouping_cols      The columns columns that defines the grouping.
        @param with_replacement   The sampling method.

    """
    with MinWarning("warning"):

        class_counts = unique_string(desp='class_counts')
        desired_sample_per_class = unique_string(desp='desired_sample_per_class')
        desired_counts = unique_string(desp='desired_counts')

        if not class_sizes or class_sizes.strip().lower() in ('null', ''):
            class_sizes = 'uniform'

        _validate_strs(source_table, output_table, class_col, class_sizes,
            output_table_size, grouping_cols, with_replacement)

        source_table_columns = ','.join(get_cols(source_table))
        grp_by = "GROUP BY {0}".format(class_col)

        _create_frequency_distribution(class_counts, source_table, class_col)
        temp_views = [class_counts]

        if class_sizes.lower() == 'undersample' and not with_replacement:
            """
                Random undersample without replacement.
                Randomly order the rows and give a unique (per class)
                identifier to each one.
                Select rows that have identifiers under the target limit.
            """
            __undersampling_with_no_replacement(source_table, output_table, class_col,
                    class_sizes, output_table_size, grouping_cols, with_replacement, 
                    class_counts, source_table_columns)

            __delete_temp_views(temp_views)
            return

        """
            Views for actual and desired samplecounts of classes 
        """
        extra_samples = True
        sampling_with_comma_delimited_class_sizes = class_sizes.find(':') > 0

        if sampling_with_comma_delimited_class_sizes:
            """                  
                Compute sample sizes based on 
                comman-delimited list of class_sizes
                and/or output_table_size
            """
            class_sizes, extra_samples = _check_formatting_and_values(class_sizes, source_table, 
                            class_col, output_table_size, class_counts)
            plpy.info(class_sizes)
            ## the following should execute only when
            ## a. output_table_size is null 
            ## b. desired_sample_sizes <= output_table_size
            temp_views.extend(_create_desired_and_actual_sampling_views(class_counts, 
                    desired_sample_per_class, desired_counts
                    , source_table, output_table, class_col 
                    , class_sizes, output_table_size))

        if class_sizes.lower() == 'uniform':
            """                  
                Compute sample sizes based on 
                uniform distribution of class sizes
            """
            temp_views.extend(_compute_uniform_class_sizes(
                class_counts, desired_sample_per_class, desired_counts
                , source_table, output_table, class_col, class_sizes, 
                output_table_size))
        
        oversampling, nosampling = False,  False
        undersampling = defaultdict(str)

        # class_sizes = '3:8,5:4,4:28'
        if sampling_with_comma_delimited_class_sizes or class_sizes.lower() == 'uniform':
            oversampling = plpy.execute("""
                select * from {desired_sample_per_class} where category = 'oversample' 
                """.format(**locals())).nrows() > 0
            if oversampling:
                with_replacement = True
            #{5:5}
            undersampling_res = plpy.execute("""
                select array_agg(concat_ws(':',classes::text,sample_class_size::text)) 
                        as undersample_set from {desired_sample_per_class} 
                where category = 'undersample' 
                """.format(**locals()))

            if undersampling_res.nrows() > 0 and undersampling_res[0]['undersample_set'] is not None:
                for val in undersampling_res[0]['undersample_set']:
                    undersampling[val.split(':')[0]] = val.split(':')[1]
                
            nosampling = plpy.execute("""
                select * from {desired_sample_per_class} where category = 'nosample' 
                """.format(**locals())).nrows() > 0
        
        plpy.info(oversampling)
        plpy.info(undersampling)
        plpy.info(nosampling)

        if class_sizes.lower() == 'oversample':
            with_replacement = True
            func_name = 'max'

        if class_sizes.lower() == 'undersample' and with_replacement:
            # undersampling with replacement.
            func_name = 'min'

        if with_replacement:
            """
                Random sample with replacement.
                Undersample will have func_name set to min
                Oversample will have func_name set to max.
            """
            """
                Create row identifiers for each row wrt the class
            """
            classwise_row_numbering_sql = """
                SELECT
                    *,
                    row_number() OVER(PARTITION BY {class_col})
                    AS __row_no
                FROM
                    {source_table}
                """.format(**locals())
            if oversampling:
                select_classes = """ WHERE {class_col}::text in 
                            (SELECT classes 
                            FROM {desired_sample_per_class} 
                            WHERE category like 'oversample')
                """.format(**locals())
                classwise_row_numbering_sql += select_classes

            """
                Create independent random values
                for each class that has a different row count than the target
            """
            if oversampling:    
                random_targetclass_size_sample_number_gen_sql = """
                SELECT
                    {desired_sample_per_class}.classes,
                    generate_series(1, sample_class_size::int) AS _i,
                    ((random()*({class_counts}.class_count-1)+1)::int)
                    AS __row_no
                FROM
                    {class_counts},
                    {desired_sample_per_class}
                WHERE 
                {desired_sample_per_class}.classes = {class_counts}.classes
                AND category like 'oversample'
                """.format(**locals())
            else:
                random_targetclass_size_sample_number_gen_sql = """
                SELECT
                    classes,
                    generate_series(1, target_class_size::int) AS _i,
                    ((random()*({class_counts}.class_count-1)+1)::int)
                    AS __row_no
                FROM
                    (SELECT
                        {func_name}(class_count) AS target_class_size
                    FROM {class_counts})
                        AS foo,
                        {class_counts}
                    WHERE {class_counts}.class_count != target_class_size
                """.format(**locals())

            """
                Match random values with the row identifiers
            """
            sample_otherclass_set = """
                SELECT
                     {source_table_columns}
                FROM
                    ({classwise_row_numbering_sql}) AS f1
                RIGHT JOIN
                    ({random_targetclass_size_sample_number_gen_sql}) AS
                        f2
                ON (f1.__row_no = f2.__row_no) AND
                (f1.{class_col}::text = f2.classes)
                """.format(**locals())

            if not oversampling:
                """
                    Find classes with target number of rows
                """
                targetclass_set = """
                    SELECT
                        {source_table_columns}
                    FROM {source_table}
                    WHERE {class_col}::text IN
                        (SELECT
                            classes AS target_class
                         FROM {class_counts}
                         WHERE class_count in
                            (SELECT {func_name}(class_count) FROM {class_counts}))
                    """.format(**locals())

                """
                    Combine target and other sampled classes
                """
                output_sql = """
                    CREATE TABLE {output_table} AS (
                        SELECT {source_table_columns}
                        FROM
                            ({targetclass_set}) AS a
                        UNION ALL
                            ({sample_otherclass_set}))
                    """.format(**locals())
                plpy.execute(output_sql)

                __delete_temp_views(temp_views)
                return

        nosample_classset_sql = """
            SELECT
                {source_table_columns}
            FROM {source_table}
            WHERE {class_col}::text IN
                (SELECT
                    classes 
                 FROM {desired_sample_per_class}
                 WHERE category like 'nosample')
                    """.format(**locals())

        undersampling_classset_sql = ''
        if len(undersampling) > 0:
            """
                Use union all to presenve the repeated samples of oversamples.
            """
            undersampling_classset_sql = ' UNION ALL'.join(""" 
                (SELECT {source_table_columns}
                FROM {source_table}
                WHERE {class_col} = '{clas}'
                ORDER BY random()
                LIMIT {limit_bound})
                """.format(source_table_columns=source_table_columns,
                            source_table=source_table,
                            class_col=class_col,
                            limit_bound=clas_limit,
                            clas=clas) for clas, clas_limit in undersampling.iteritems())
            undersampling_classset_sql = ' UNION ALL ' + undersampling_classset_sql

        oversampling_classset_sql = ''
        if oversampling:
            oversampling_classset_sql = """ 
                    UNION ALL
                        ({sample_otherclass_set})
                        """.format(**locals())

        if (oversampling or len(undersampling) > 0):
            """
                Combine target and other over sampled classes
                sample_otherclass_set
            """
            if not extra_samples:
                nosample_classset_sql.replace('nosample', '')

            output_sql = """
                CREATE TABLE {output_table} AS (
                    SELECT {source_table_columns}
                    FROM
                        ({nosample_classset_sql}) AS a
                    {oversampling_classset_sql}
                    {undersampling_classset_sql}) 
                """.format(**locals())
            plpy.info(output_sql)
            plpy.execute(output_sql)

        __delete_temp_views(temp_views)
    return

def __delete_temp_views(temp_views):
    for temp_view in temp_views:
            plpy.execute("DROP VIEW IF EXISTS {0} cascade".format(temp_view))
    return

"""
    Random undersample without replacement.
"""
def __undersampling_with_no_replacement(source_table, output_table, class_col,
        class_sizes, output_table_size, grouping_cols, with_replacement, 
        class_counts, source_table_columns):

    distinct_class_labels = plpy.execute("""
        SELECT array_agg(DISTINCT {class_col}::text) AS labels
        FROM {source_table}
        """.format(**locals()))[0]['labels']

    limit_bound = plpy.execute("""
        SELECT MIN(class_count)::int AS min
        FROM {class_counts}""".format(**locals()))[0]['min']

    minority_class = plpy.execute("""
        SELECT array_agg(classes::text) as minority_class
        FROM {class_counts}
        WHERE class_count = {limit_bound}
        """.format(**locals()))[0]['minority_class']

    distinct_class_labels = [cl for cl in distinct_class_labels
                                if cl not in minority_class]

    foo_table = unique_string(desp='foo')
    start_selection_qry = """
        SELECT {source_table_columns} 
        FROM (
            SELECT {source_table_columns}
            FROM {source_table}
            WHERE {class_col}::text = {dcl}::text
            ORDER BY random()
            LIMIT {limit_bound}
            ) AS {foo_table}
        UNION """.format(dcl=distinct_class_labels[0], **locals())

    union_qry = ' UNION '.join(""" 
        (SELECT {source_table_columns}
        FROM {source_table}
        WHERE {class_col}::text = '{val}'
        ORDER BY random()
        LIMIT {limit_bound})
        """.format(source_table_columns=source_table_columns,
                    source_table=source_table,
                    class_col=class_col,
                    limit_bound=limit_bound,
                    val=val) for val in distinct_class_labels[1:])

    min_class_tuple = "('" + "','".join([str(a) for a in minority_class]) + "')"

    minority_sql = """ UNION
        SELECT {source_table_columns}
        FROM {source_table}
        WHERE {class_col} IN {min_class_tuple} """.format(**locals())

    output_sql = """
        CREATE TABLE {output_table} AS (
            {start_selection_qry}
            {union_qry}
            {minority_sql} )""".format(**locals())
    #plpy.info(output_sql)
    plpy.execute(output_sql)

class UniqueDict(dict):
    def __setitem__(self, key, value):
        if key not in self:
            # float(value).is_integer() ensures only whole numbers.
            if (value > 0.0 or value < 1.0) or (value >= 1.0 and float(value).is_integer()):
                dict.__setitem__(self, key, value)
            else:
                plpy.error("Sample: Value should be between (0.0,1.0) or value is a whole number greater then 1")
                #raise KeyError("Sample: Value should be between (0.0,1.0) or value is a whole number greater then 1")
        else:
            plpy.error("Sample: Same Key specified multiple times in class_sizes")
            #raise ValueError("Sample: Same Key specified multiple times in class_sizes")


def __check_value_type(value):
    import re
    if re.match("^\d+?\.\d+?$", value) is not None and not float(value).is_integer():
        valueType = float
    elif (re.match(r"[-+]?\d+$", value) is not None):
        valueType = int
    return valueType

def _check_formatting_and_values(class_sizes, source_table, class_col,
                    output_table_size, class_counts):

    mod_class_sizes = ''

    # errors on same classes e.g class_sizes = '3:4,5:6,10:4,6:0.4,5:0.4' 
    # errors on different value types (numeric and fractions) class_sizes = '3:4,5:6,10:4,6:0.4' errors on value?
    # ensure keys in the class_col.
    # class_sizes = '3:4,5:6,10:4,6:4,5:4' # error duplicate keys
    # class_sizes = '3:0.4,5:0.6,10:4,6:0.4,5:0.4' # must have same type of values
    # class_sizes = '3:a,5:b' # error values are string
    #class_sizes = '3:0.2,4:0.3,6:0.5'
    class_sizes_arr = class_sizes.split(',')
    plpy.info([0])
    firstValue = class_sizes_arr[0].split(':')[1]

    try:
        float(firstValue)
    except ValueError:
        # plpy.error("Sample: Value is neither a float or integer")
        raise ValueError("Sample: Specify either fractions or whole numbers for each class sample size.")

    firstValueType = __check_value_type(firstValue)
    plpy.info(firstValueType)
    #contains_fractions = False if firstValueType != float else True

    cs_dict = UniqueDict(defaultdict())
    cs_dict[class_sizes_arr[0].split(':')[0]] = firstValueType(firstValue)
    
    numeric_value_sum = 0
    fraction_value_sum = 0.0
    if len(class_sizes_arr) > 1 :
        for x in class_sizes_arr[1:]:
            val = x.split(':')
            # Following error type is invalidated by Frank as of 29th Dec.
            # if __check_value_type(val[1].strip(), firstValueType) != firstValueType:
                #plpy.error("Sample: Specify either fractions or whole number values for ALL classes.")
            valueType = __check_value_type(val[1])
            fraction_value_sum += valueType(val[1]) if valueType == float else 0.0
            numeric_value_sum += valueType(val[1]) if valueType != float else 0
            cs_dict[val[0].strip()] = valueType(val[1])

    all_classes = cs_dict.keys()

    # Check to see if specified classes are present in the class_col
    if len(all_classes) > 1:
        all_classes = str(all_classes)[1:-1]

    does_all_specified_class_exists = plpy.execute("""
            select 
                unnest(ARRAY[{all_classes}]) 
            except 
            select 
                distinct({class_col}::text) 
            from {source_table}
        """.format(**locals()))

    if does_all_specified_class_exists.nrows() > 0:
        plpy.error("""Sample: Specified classes do not exist in {class_col}""".format(**locals()))

    if fraction_value_sum > 1.0 or (fraction_value_sum == 1.0 and numeric_value_sum != 0):
        plpy.error("""Sample: Fraction sum < 1.0 ( or at most 1.0 only 
                when further sampling in whole numbers is specified ) 
            """.format(**locals()))


    total_table_size = plpy.execute("""
            select 
                count(*) as total 
            from {source_table}
        """.format(**locals()))[0]['total']

    #extra_samples keeps track of keeping remaining samples as is.
    # is always true in output_table_size Null cases
    extra_samples = True

    # no fractions are present
    if fraction_value_sum == 0.0: 
        # there are no fractions present in class_sizes 
        if (not output_table_size): 
            # sample others uniformly with class_sizes given   
            return class_sizes, extra_samples

        if output_table_size < numeric_value_sum:
            plpy.error("""Sample: Output table size ({output_table_size}) must be more than total specified sample size i.e {numeric_value_sum}""".format(**locals()))
            
        if output_table_size == numeric_value_sum:
            # no need to sample other classes
            return class_sizes, False

        return class_sizes, True

    # only fractions are present which also sum to 1.0
    if fraction_value_sum == 1.0:
        ## No need for sampling other classes
        return _compute_class_sizes(cs_dict, total_table_size), False

    # Compute class distributions for comma-delimited fractions
    # and class_sizes with both comma-delimited fractions and 
    # comma-delimited whole number samples
    if fraction_value_sum > 0:
        # if output table size is null
        sum_remaining_class_samples = plpy.execute("""
                select sum(class_counts) as remaining_classes from {class_counts} 
                where classes not in ({all_classes})
                """.format(**locals()))
        if (not output_table_size):

            y = 1.0 - fraction_value_sum
            if sum_remaining_class_samples.nrows() > 0:
                numeric_value_sum += sum_remaining_class_samples[0]['remaining_classes']
            if numeric_value_sum == 0:
                # this case happens only when there is only one class present in class col
                return _compute_class_sizes(cs_dict, total_table_size), False

            x = float(numeric_value_sum) / y
            class_size = _compute_class_sizes(cs_dict, x)

            return class_size, extra_samples

        # if output_table_size is given:
        output_table_size = float(output_table_size)
        fractional_classes_sample_size = output_table_size * fraction_value_sum
        total_desired_sample_size = fractional_classes_sample_size + numeric_value_sum
        
        if total_desired_sample_size > output_table_size:
            plpy.error("""Sample: Output table size ({output_table_size}) must be more than total desired sample size i.e {total_desired_sample_size}""".format(**locals()))
            
        if total_desired_sample_size == output_table_size:
            # no need to sample other classes
            # fractions should be multiplied by output_table_size to get proper whole number values
            return _compute_class_sizes(cs_dict, output_table_size), False   

        if total_desired_sample_size < output_table_size:
            # Sample other classes uniformly
            # fractions should be multiplied by output_table_size to get proper whole number values
            return _compute_class_sizes(cs_dict, output_table_size), True   
        
def _compute_class_sizes(cs_dict, x):
    class_size = ''
    for clas, class_size in cs_dict.iteritems():
        if float(class_sizes).is_integer():
            class_size += str(clas) + ':' + str(class_size) + ','
        else:
            class_size += str(clas) + ':' + str(ceil(class_size * x)) + ','
    plpy.info(class_size)
    return class_size[:-1]

# create frqguency distribution of source table
def _create_frequency_distribution(class_counts, source_table, class_col):

    grp_by = "GROUP BY {0}".format(class_col)
    """
        Frequency view of classes
    """
    plpy.execute(""" CREATE VIEW {class_counts} AS (
                 SELECT
                    {class_col}::text AS classes,
                    count(*) AS class_count
                 FROM {source_table}
                    {grp_by})
             """.format(**locals()))    

# Function to create frequency counts and desired counts table.
def _create_desired_and_actual_sampling_views(class_counts, desired_sample_per_class, desired_counts
            , source_table, output_table, class_col, class_sizes, output_table_size):

    if len(class_sizes.split(',')) > 1:
        values = '\',\''.join(class_sizes.split(','))
    else:
        values = class_sizes.split(',')[0] 

    create_desired_counts_sql = """
        create view {desired_counts} as (
        select val[1]::text as desired_classes,
               val[2]::int as desired_values 
        from 
            (select regexp_split_to_array(unnest(ARRAY['{values}']),E':') as val) 
            ---(select regexp_split_to_array(unnest(ARRAY[['3:9','5:5','4:5']]),E':') as val)
        as foo
        )
    """.format(**locals())
    plpy.execute(create_desired_counts_sql)

    extra_class_samples = ''
    if output_table_size:
        
        extra_class_samples = _sample_extra_classes_uniformly_per_output_table_size(
            class_counts, desired_counts, output_table_size)
        
        desired_sample_per_class_sql = """
        create view {desired_sample_per_class} as (
            select 
                    classes,
                    desired_values::int as sample_class_size,
                    class_count as actual_class_size,
                    case 
                      when (desired_values - class_count) = 0 then 'nosample'
                      when (desired_values - class_count) > 0 then 'oversample' else 'undersample' 
                    end  as category
            from (
                select  
                        classes,
                        case (select 1 where desired_values is null)
                            when 1 then extra_values
                            else desired_values
                        end as desired_values,
                        class_count 
                from 
                    {class_counts}
                     left join
                    {desired_counts}
                    on ({class_counts}.classes = {desired_counts}.desired_classes)
                    left join
                    {extra_class_samples}
                    on ({class_counts}.classes = {extra_class_samples}.extra_classes)
                    ) as foo
            )
        """.format(**locals())
    else:
        desired_sample_per_class_sql = """
            create view {desired_sample_per_class} as (
                select 
                        classes,
                        desired_values::int as sample_class_size,
                        class_count as actual_class_size,
                        case 
                          when (desired_values - class_count) = 0 then 'nosample'
                          when (desired_values - class_count) > 0 then 'oversample' else 'undersample' 
                        end  as category
                from (
                    select  
                            classes,
                            case (select 1 where desired_values is null)
                                when 1 then class_count
                                else desired_values
                            end as desired_values,
                            class_count 
                    from 
                        {class_counts}
                         left join
                        {desired_counts}
                        on ({class_counts}.classes = {desired_counts}.desired_classes)
                        ) as foo
                )
            """.format(**locals())

    #plpy.info(desired_sample_per_class_sql)
    plpy.execute(desired_sample_per_class_sql)
    temp_views = [desired_counts, desired_sample_per_class]
    if extra_class_samples:
        temp_views.extend([extra_class_samples])
    return temp_views

def _sample_extra_classes_uniformly_per_output_table_size(class_counts 
                , desired_counts, output_table_size):

    extra_class_samples = unique_string(desp='extra_class_samples')
    foo_table = unique_string(desp='foo')
    extra_class_samples_sql = """
        create view {extra_class_samples} as (
            select  
                extra_classes, 
                round(((desired_total_size - desired_total_class_size)::FLOAT8)/((total_classes - desired_distinct_class_count)::FLOAT8)) as extra_values
            from
                (select 
                    {output_table_size}::float8 as desired_total_size) 
                        as constant_output_table_size,
                (select 
                    sum(desired_values) as desired_total_class_size, 
                    count(*) as desired_distinct_class_count 
                from {desired_counts}) 
                        as user_desired_class_sizes,
                (select 
                    --sum(class_count) as total_size, 
                    count(*) as total_classes 
                from {class_counts}) 
                        as actual_table_frequencies,
                (select 
                    classes as extra_classes
                from 
                    (select 
                        classes 
                    from {class_counts}
                        except
                    select 
                        desired_classes 
                    from {desired_counts}
                    ) as {foo_table}) 
                        as remaining_classes)
        """.format(**locals())

    plpy.execute(extra_class_samples_sql)
    return extra_class_samples


def _compute_uniform_class_sizes( class_counts, desired_sample_per_class, desired_counts
                , source_table, output_table, class_col, class_sizes, 
                output_table_size):

    calculated_sample_per_class = unique_string(desp='calculated_sample_per_class')
    foo_table = unique_string(desp='foo')

    output_table_sql = ''
    if output_table_size:
        output_table_sql = """
                (select {output_table_size}::float8 as a) as {foo_table}
        """.format(**locals())
    else:
        output_table_sql = """
                (select count(*)::float8 as a from {source_table}) as {foo_table}
        """.format(**locals())

    calculated_sample_per_class_sql = """
        create view {calculated_sample_per_class}  as (
            select 
                ceil(a/b) as sample_size 
                ---,mod(a,b::int) as remaining_instances_to_sample 
            from 
                {output_table_sql},
                (select count(distinct({class_col}))::float8 b from {source_table}) as bar  
        )  
        """.format(**locals())
    plpy.execute(calculated_sample_per_class_sql)

    desired_sample_per_class_sql = """
        create view {desired_sample_per_class} as (
            select 
                classes,
                uniform_sample_size as sample_class_size,
                class_count as actual_class_size,
                case 
                    when (uniform_sample_size - class_count) = 0 then 'nosample'
                    when (uniform_sample_size - class_count) > 0 then 'oversample' else 'undersample' 
                end as category
            from 
                (select 
                        classes,
                        sample_size as uniform_sample_size,
                        class_count
                  from
                      {class_counts},
                      {calculated_sample_per_class}
                ) as foo)
        """.format(**locals())
    plpy.execute(desired_sample_per_class_sql)

    temp_views = [calculated_sample_per_class, desired_sample_per_class, foo_table]

    return temp_views


def _validate_strs (source_table, output_table, class_col, class_sizes,
            output_table_size, grouping_cols, with_replacement):

    _assert(table_exists(source_table),
        "Sample: Source table ({source_table}) is missing!".format(**locals()))
    _assert(not table_is_empty(source_table),
        "Sample: Source table ({source_table}) is empty!".format(**locals()))

    _assert(output_table and output_table.strip().lower() not in ('null', ''),
        "Sample: Invalid output table name {output_table}!".format(**locals()))
    _assert(not table_exists(output_table),
        "Sample: Output table ({output_table}) already exists!".format(**locals()))

    _assert(columns_exist_in_table(source_table, [class_col]),
        ("""Sample: Column {class_col} does not exist in"""+
            """ table ({source_table}).""").format(**locals()))

    if class_sizes.lower() == 'oversample' and with_replacement is False:
        plpy.error("Sample: Cannot use without replacement with "
                    "oversampling.")

    if class_sizes.lower() == 'oversample' and output_table_size:
        plpy.error("Sample: Cannot set output_table_size with "
                    "oversampling.")

    if class_sizes.lower() == 'undersample' and output_table_size:
        plpy.error("Sample: Cannot set output_table_size with "
                    "undersampling.")

    if class_sizes.find(':') > 0 and with_replacement is not None:
        plpy.error("Sample: Cannot use without replacement with "
                    "comman-delimited class sizes.")

    # Future options to be implemented
    # _assert(class_sizes in ('undersample', 'oversample'),
    #     "Sample: Only undersampling is supported at the moment."
    #     .format(**locals()))

    # _assert(output_table_size is None,
    #     "output_table_size is not supported at the moment."
    #     .format(**locals()))

    _assert(grouping_cols is None,
        "grouping_cols is not supported at the moment."
        .format(**locals()))

    return


def balance_sample_help(schema_madlib, message, **kwargs):
    """
    Help function for balance_sample

    Args:
        @param schema_madlib
        @param message: string, Help message string
        @param kwargs

    Returns:
        String. Help/usage information
    """
    if not message:
        help_string = """
-----------------------------------------------------------------------
                            SUMMARY
-----------------------------------------------------------------------
Given a table with varying set of records for each class label,
this function will create an output table with a varying types (by
default: uniform) of sampling distributions of each class label. It is
possible to use with or without replacement sampling methods, specify
different proportions of each class, multiple grouping columns and/or
output table size.

For more details on function usage:
    SELECT {schema_madlib}.balance_sample('usage');
    SELECT {schema_madlib}.balance_sample('example');
            """
    elif message.lower() in ['usage', 'help', '?']:
        help_string = """

Given a table, stratified sampling returns a proportion of records for
each group (strata). It is possible to use with or without replacement
sampling methods, specify a set of target columns, and assume the
whole table is a single strata.

----------------------------------------------------------------------------
                            USAGE
----------------------------------------------------------------------------

 SELECT {schema_madlib}.balance_sample(
    source_table      TEXT,     -- Input table name.
    output_table      TEXT,     -- Output table name.
    class_col         TEXT,     -- Name of column containing the class to be
                                -- balanced.
    class_size        TEXT,     -- (Default: NULL) Parameter to define the size
                                -- of the different class values.
    output_table_size INTEGER,  -- (Default: NULL) Desired size of the output
                                -- data set.
    grouping_cols     TEXT,     -- (Default: NULL) The columns columns that
                                -- defines the grouping.
    with_replacement  BOOLEAN   -- (Default: FALSE) The sampling method.

If class_size is NULL, the source table is uniformly sampled.

If output_table_size is NULL, the resulting output table size will depend on
the settings for the ‘class_size’ parameter. It is ignored if ‘class_size’
parameter is set to either ‘oversample’ or ‘undersample’.

If grouping_cols is NULL, the whole table is treated as a single group and
sampled accordingly.

If with_replacement is TRUE, each sample is independent (the same row may
be selected in the sample set more than once). Else (if with_replacement
is FALSE), a row can be selected at most once.
);
"""
    elif message.lower() in ("example", "examples"):
        help_string = """
----------------------------------------------------------------------------
                                EXAMPLES
----------------------------------------------------------------------------

-- Create an input table
DROP TABLE IF EXISTS test;

CREATE TABLE test(
    id1 INTEGER,
    id2 INTEGER,
    gr1 INTEGER,
    gr2 INTEGER
);

INSERT INTO test VALUES
(1,0,1,1),
(2,0,1,1),
(3,0,1,1),
(4,0,1,1),
(5,0,1,1),
(6,0,1,1),
(7,0,1,1),
(8,0,1,1),
(9,0,1,1),
(9,0,1,1),
(9,0,1,1),
(9,0,1,1),
(0,1,1,2),
(0,2,1,2),
(0,3,1,2),
(0,4,1,2),
(0,5,1,2),
(0,6,1,2),
(10,10,2,2),
(20,20,2,2),
(30,30,2,2),
(40,40,2,2),
(50,50,2,2),
(60,60,2,2),
(70,70,2,2)
;

-- Sample without replacement
DROP TABLE IF EXISTS out;
SELECT balance_sample('test', 'out', 'gr1', 'undersample', NULL, NULL, FALSE);
SELECT * FROM out;

--- Sample with replacement
DROP TABLE IF EXISTS out_sr2;
SELECT balance_sample('test', 'out', 'gr1', 'undersample', NULL, NULL, TRUE);
SELECT * FROM out;
"""
    else:
        help_string = "No such option. Use {schema_madlib}.graph_sssp()"

    return help_string.format(schema_madlib=schema_madlib)
